#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from actcancelstructs import *
import threading as tr
import errno

from ActiveCancelclibase import *
class CIActiveCancelcli( IIActiveCancel_CliImpl ):

    sem = tr.Semaphore( 0 )
    iError = 0

    def SetError( self, ret ):
        self.iError = ret

    def GetError( self ):
        return self.iError

    def WaitForComplete( self ):
        self.sem.acquire()

    def NotifyComplete( self ):
        self.sem.release()

    '''
    Asynchronous callback to receive the 
    request status, and reponse parameters
    if any. And add code here to process the
    request response
    '''
    def LongWaitCb( self,
        context : object, ret : int, 
        i0r : str ) :
        if ret < 0 :
            print( "LongWaitCb failed with error " + str( ret ) )
        else :
            print( "LongWaitCb complete with resp " + i0r )
        self.SetError( ret )
        self.NotifyComplete()
        
    
class CActiveCancelProxy(
    CIActiveCancelcli,
    PyRpcProxy ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        PyRpcProxy.__init__( self,
            pIoMgr, strDesc, strObjName )
