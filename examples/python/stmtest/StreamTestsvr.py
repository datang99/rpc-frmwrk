#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from stmteststructs import *
import errno
import threading as tr

from StreamTestsvrbase import *
class TransferContext :
    def __init__( self ) :
        self.iCounter = 0
        self.iError = 0

    def IncCounter( self ) :
        self.iCounter += 1

    def GetCounter( self ) :
        return self.iCounter

    def SetError( self, i ) :
        self.iError = i

    def GetError( self ) :
        return self.iError


class CIStreamTestsvr( IIStreamTest_SvrImpl ):

    '''
    Synchronous request handler
    '''
    def Echo( self, oReqCtx : PyReqContext,
        i0 : str
        ) -> Tuple[ int, list ] :
        '''
        the response parameters includes
        i0r : str
        '''
        #Implement this method here
        return [ ErrorCode.STATUS_SUCCESS, [i0,] ]

    def ReadStmCallback( self, iRet, hChannel, pBuf ) :
        if iRet < 0:
            OutputMsg( "ReadStreamAsync2 failed with error " +
                str( iRet ) )
            return

        OutputMsg( "Proxy says: " + pBuf.decode() )
        self.WriteAndReceive( hChannel )
        return

    def WriteStmCallback( self, iRet, hChannel, pBuf ) :
        if iRet < 0:
            OutputMsg( "WriteStreamAsync2 failed with error " +
                str( iRet ) )
            return

        context = self.GetChanCtx( hChannel )
        if context is None:
            return
        context.IncCounter()
        self.ReadAndReply( hChannel )
        return

    def OnStmReady( self, hChannel ):
        greeting = "Hello, Proxy"
        self.WriteStreamNoWait(
            hChannel, greeting.encode() )

        tc = TransferContext()
        self.SetChanCtx( hChannel, tc )
        self.ReadAndReply(hChannel)


    def OnStmClosing( self, hChannel ):
        context = self.GetChanCtx( hChannel )
        if context is None:
            return

        OutputMsg( "Stream " + str( hChannel ) +
            " is closing with status " +
            str( context.GetError() ) )
        return

    def ReadAndReply( self, hChannel : int )->int:
        ret = 0
        context = self.GetChanCtx( hChannel )
        if context is None:
            ret = -ErrorCode.EFAULT
            return ret

        while True:
            pret = self.ReadStreamAsync2( hChannel, 0 )
            if pret[ 0 ] < 0:
                ret = pret[ 0 ]
                break

            if pret[ 0 ] == ErrorCode.STATUS_PENDING:
                # ReadStmCallback will handle it
                ret = 0
                break

            byResp = pret[ 1 ]
            OutputMsg( "Proxy says: " + byResp.decode() )
            idx = context.GetCounter()
            strMsg = "This is message " + str( idx )
            print("haha" + str(idx))

            ret = self.WriteStreamAsync2(
                hChannel, strMsg.encode() )
            if ret < 0 :
                break

            if ret == ErrorCode.STATUS_PENDING:
                ret = 0
                break

            #most likely branch
            context.IncCounter()

        if ret < 0:
            OutputMsg( "ReadAndReply failed with error " +
                str( ret ) )
            context.SetError( ret )

        return ret
        
    def WriteAndReceive( self, hChannel : int ) ->int:
        ret = 0
        context = self.GetChanCtx( hChannel )
        if context is None:
            return -ErrorCode.EFAULT

        while True:
            idx = context.GetCounter()
            strMsg = "This is message " + str(idx)
            ret = self.WriteStreamAsync2(
                hChannel, strMsg.encode() )
            if ret < 0:
                break

            if ret == ErrorCode.STATUS_PENDING:
                ret = 0
                break
            context.IncCounter()
            pret = self.ReadStreamAsync2( hChannel, 0 )
            if pret[ 0 ] < 0:
                ret = pret[ 0 ]
                break

            if pret[ 0 ] == ErrorCode.STATUS_PENDING:
                ret = 0
                break

            byResp = pret[ 1 ]
            OutputMsg( "proxy says: " + byResp.decode() )


        if ret < 0 :
            context.SetError( ret )
            OutputMsg( "WriteAndReceive failed with error " +
                str(ret) )
        return ret

class CStreamTestServer(
    CIStreamTestsvr,
    PyRpcServer ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        PyRpcServer.__init__( self,
            pIoMgr, strDesc, strObjName )
