#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from sfteststructs import *
import errno
import os
from TransFileContext import TransFileContext
from TransferContext import TransferContext
import re

from FileTransfersvrbase import *
class CIFileTransfersvr( IIFileTransfer_SvrImpl ):

    def __init__(self):
        self.m_strRootDir = "/tmp/sfsvr-root/" + os.getlogin()
        if not os.path.exists(self.m_strRootDir) :
            os.makedirs( self.m_strRootDir )
        self.m_oTransctx = TransferContext(self)

    def IsFileNameValid( self, strFile : str) -> bool:
        regex = '^[A-Za-z0-9_][A-Za-z0-9_.]*'
        return re.search(regex, strFile)
            

    '''
    Synchronous request handler
    '''
    def StartUpload( self, oReqCtx : PyReqContext,
        strFile : str,
        hChannel : int,
        qwOffset : int,
        qwSize : int
        ) -> Tuple[ int, None ] :

        if not self.IsFileNameValid(strFile):
            return [-errno.EINVAL,]
        o = TransFileContext( strFile )
        o.m_cDirection = 'u'
        o.m_iSize = qwSize
        o.m_iOffset = qwOffset
        o.m_bServer = self.IsServer()
        o.m_strPath = self.m_strRootDir + "/" + strFile

        while True:
            ret = o.OpenFile()
            if ret < 0:
                break
            ret = self.m_oTransctx.AddContext(
                hChannel, o)
            if ret < 0:
                break

            # schedule a deferred call to start receiving file content
            odc = lambda self, tc, hChannel : tc.WriteFileAndRecv( hChannel, bytearray() )
            ret = self.DeferCall(
                odc, self.m_oTransctx, hChannel )
            break
        
        return [ ret, None ]
        
    '''
    Synchronous request handler
    '''
    def StartDownload( self, oReqCtx : PyReqContext,
        strFile : str,
        hChannel : int,
        qwOffset : int,
        qwSize : int
        ) -> Tuple[ int, None ] :

        #check validity of the file name
        if not self.IsFileNameValid(strFile):
            return [-errno.EINVAL,]

        o = TransFileContext( strFile )
        o.m_cDirection = 'd'
        o.m_strPath = self.m_strRootDir + "/" + strFile
        o.m_iSize = qwSize
        o.m_iOffset = qwOffset
        o.m_bServer = self.IsServer()

        while True:
            ret = o.OpenFile()
            if ret < 0:
                break

            self.m_oTransctx.AddContext(hChannel, o)
            odc = lambda self, tc, hChannel : tc.ReadFileAndSend(hChannel)
            ret = self.DeferCall(
                odc, self.m_oTransctx, hChannel)
            break

        return [ ret, None ]
        
    '''
    Synchronous request handler
    '''
    def GetFileInfo( self, oReqCtx : PyReqContext,
        strFile : str
        ) -> Tuple[ int, list ] :
        '''
        the response parameters includes
        fi : FileInfo
        '''
        #check validity of the file name
        if not self.IsFileNameValid(strFile):
            return [-errno.EINVAL,]
        ret = 0
        fi = FileInfo()
        while True:
            strPath = self.m_strRootDir + "/" + strFile
            fi.strFile = strFile
            if not os.path.exists(strPath):
                ret = -errno.ENOENT
                break

            if not os.path.isfile(strPath):
                ret = -errno.EBADF
                break
            strAccess = ""
            if os.access(strPath, os.R_OK ):
                strAccess += "r"
            else :
                strAccess += '-'
            
            if os.access(strPath, os.W_OK ) :
                strAccess += 'w'
            else :
                strAccess += '-'
            
            if os.access(strPath, os.X_OK ):
                strAccess += 'x'
            else :
                strAccess += '-'
            fi.strAccess = strAccess
            fi.qwSize = os.path.getsize(strPath)

            break

        if ret < 0 :
            return [ ret, None ]

        return [ ErrorCode.STATUS_SUCCESS, [fi,] ]
        
    '''
    Synchronous request handler
    '''
    def RemoveFile( self, oReqCtx : PyReqContext,
        strFile : str
        ) -> Tuple[ int, None ] :
        if not self.IsFileNameValid(strFile) :
            return [ -errno.EINVAL, ]

        ret = 0
        strPath = self.m_strRootDir + "/" + strFile
        if os.path.exists(strPath) and os.path.isfile(strPath):
            os.remove(strPath)
        else:
            ret = -errno.ENOENT
        return [ ret, None ]
        
    def WriteStmCallback(
        self, iRet : int, hChannel: int, buf : bytearray):
        if iRet < 0:
            OutputMsg("WriteStreamAsync2 failed with error " + str(iRet))
            return
        self.m_oTransctx.WriteStmCallback( hChannel, buf )

    def ReadStmCallback(
        self, iRet : int, hChannel: int, buf : bytearray):
        if iRet < 0:
            OutputMsg("ReadStreamAsync2 failed with error " + str(iRet))
            return
        self.m_oTransctx.ReadStmCallback( hChannel, buf )

    def OnStmReady( self, hChannel : int) -> int:
        odc = lambda self, tc, hChannel : tc.SendToken( hChannel, "rdy".encode())
        self.DeferCall(odc, self.m_oTransctx, hChannel)
        return 0

    def OnStmClosing( self, hChannel : int) :
        self.m_oTransctx.OnTransferDone(
            hChannel, -errno.ECONNABORTED )
        return 0

class CFileTransferServer(
    CIFileTransfersvr,
    PyRpcServer ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        CIFileTransfersvr.__init__(self)
        PyRpcServer.__init__( self,
            pIoMgr, strDesc, strObjName )
