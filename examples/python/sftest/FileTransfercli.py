#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from sfteststructs import *
import errno
from TransferContext import TransferContextCli
from TransFileContext import TransFileContext
import os

from FileTransferclibase import *
class CIFileTransfercli( IIFileTransfer_CliImpl ):

    def __init__(self) :
        self.m_oTransCtx = TransferContextCli(self)
    
    def UploadFile( self, hChannel : int, strFile : str ):
        if hChannel == ErrorCode.INVALID_HANDLE or strFile == "":
            return -errno.EINVAL

        if not ( os.path.exists(strFile) and os.path.isfile(strFile) ) :
            return -errno.ENOENT

        ret = 0
        while True:
            o = TransFileContext(strFile)
            o.m_cDirection = 'u'
            o.m_strPath = strFile
            o.m_bServer = self.IsServer()

            ret = o.OpenFile()
            if ret < 0:
                break

            ret = self.m_oTransCtx.AddContext(hChannel, o)
            if ret < 0:
                break

            strRemoteName = os.path.basename(strFile)
            if strRemoteName == "" :
                ret = -errno.EINVAL
                break

            pret = self.StartUpload(
                strRemoteName, hChannel, 0, o.m_iSize )

            if pret[ 0 ] < 0:
                ret = pret[ 0 ]
                break

            ret = self.m_oTransCtx.ReadFileAndSend(hChannel)
            break

        return ret

    def DownloadFile( self, hChannel : int,
        strFile : str, offset : int, size : int) :

        if hChannel == ErrorCode.INVALID_HANDLE or strFile == "":
            return -errno.EINVAL

        ret = 0
        while True:
            o = TransFileContext(strFile)
            o.m_cDirection = 'd'
            o.m_strPath = "./" + strFile + ".1"
            o.m_bServer = self.IsServer()
            o.m_iOffset = offset
            o.m_iSize = size

            ret = o.OpenFile()
            if ret < 0 :
                break
            ret = self.m_oTransCtx.AddContext( hChannel, o )
            if ret < 0:
                break

            pret = self.StartDownload(
                strFile, hChannel, offset, size)

            if pret[ 0 ] < 0:
                ret = pret[ 0 ]
                break
            ret = self.m_oTransCtx.WriteFileAndRecv(
                hChannel,bytearray())
            break

        return ret

    def WriteStmCallback( self,
        iRet : int, hChannel : int, buf : bytearray ) :
        if iRet < 0:
            OutputMsg("WriteStreamAsync2 failed with error " + str(iRet))
            return
        self.m_oTransCtx.WriteStmCallback(hChannel, buf)

    def ReadStmCallback( self,
        iRet : int, hChannel : int, buf : bytearray ) :
        if iRet < 0:
            OutputMsg("ReadStreamAsync2 failed with error " + str(iRet))
            return
        self.m_oTransCtx.ReadStmCallback(hChannel, buf)

    def OnStmClosing(self, hChannel ) :
        self.m_oTransCtx.OnTransferDone(
            hChannel, -errno.ECONNABORTED)
        return 0

class CFileTransferProxy(
    CIFileTransfercli,
    PyRpcProxy ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        CIFileTransfercli.__init__(self)
        PyRpcProxy.__init__( self,
            pIoMgr, strDesc, strObjName )
