// GENERATED BY RIDLC, MAKE SURE TO BACKUP BEFORE RUNNING RIDLC AGAIN
// Copyright (C) 2023  zhiming <woodhead99@gmail.com>
// This program can be distributed under the terms of the GNU GPLv3.
// ridlc -bO . ../../testypes.ridl 
// Implement the following methods
// to get the RPC proxy/server work
#include "rpc.h"
using namespace rpcf;
#include "TestTypes.h"
#include "TestTypesSvcsvr.h"

// ITestTypes Server
/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::Echo(
    const std::string& strText /*[ In ]*/,
    std::string& strResp /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    strResp = strText;
    return STATUS_SUCCESS;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoByteArray(
    BufPtr& pBuf /*[ In ]*/,
    BufPtr& pRespBuf /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoArray(
    std::vector<gint32>& arrInts /*[ In ]*/,
    std::vector<gint32>& arrIntsR /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoMap(
    std::map<gint32,std::string>& mapReq /*[ In ]*/,
    std::map<gint32,std::string>& mapResp /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoMany(
    gint32 i1 /*[ In ]*/,
    gint16 i2 /*[ In ]*/,
    gint64 i3 /*[ In ]*/,
    float i4 /*[ In ]*/,
    double i5 /*[ In ]*/,
    const std::string& szText /*[ In ]*/,
    gint32& i1r /*[ Out ]*/,
    gint16& i2r /*[ Out ]*/,
    gint64& i3r /*[ Out ]*/,
    float& i4r /*[ Out ]*/,
    double& i5r /*[ Out ]*/,
    std::string& szTextr /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoStruct(
    FILE_INFO& fi /*[ In ]*/,
    FILE_INFO& fir /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoNoParams()
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

/* Sync Req Handler*/
gint32 CTestTypesSvc_SvrImpl::EchoStream(
    HANDLE hstm_h /*[ In ]*/,
    HANDLE& hstmr_h /*[ Out ]*/ )
{
    // TODO: Process the sync request here 
    // return code can be an Error or
    // STATUS_SUCCESS
    return ERROR_NOT_IMPL;
}

