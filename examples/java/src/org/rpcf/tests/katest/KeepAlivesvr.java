// GENERATED BY RIDLC. MAKE SURE TO BACKUP BEFORE RE-COMPILING.
package org.rpcf.tests.katest;
import org.rpcf.rpcbase.*;
import java.util.Map;
import java.util.HashMap;
import java.lang.String;
import java.nio.ByteBuffer;

public class KeepAlivesvr extends KeepAlivesvrbase
{
    public KeepAlivesvr( ObjPtr pIoMgr,
        String strDesc, String strSvrObj )
    { super( pIoMgr, strDesc, strSvrObj ); }
    
    // IKeepAlive::LongWait async-handler
    public int LongWait(
        JavaReqContext oReqCtx,
        String i0 )
    {
        // Asynchronous handler.
        IUserTimerCb oTimerCb = new IUserTimerCb() {
            public void onTimer(Object octx, int iRet) {
                JavaReqContext oReqCtx = (JavaReqContext)octx;
                Object oData = oReqCtx.getUserData();
                if (oData != null) {
                    ObjPtr oTimer = (ObjPtr)oData;
                    oTimer.Clear();
                }
                rpcbase.JavaOutputMsg("LongWait complete with \"" + i0 + "\"");
                oReqCtx.onServiceComplete(0, new Object[]{i0});
            }
        };
        int ret = 0;
        // let's complete the request in 295 seconds
        JRetVal jret = this.addTimer(295, oTimerCb, oReqCtx);
        if (jret.SUCCEEDED()) {
            oReqCtx.setUserData(jret.getAt(0));
            ret = RC.STATUS_PENDING;
        } else {
            ret = jret.getError();
            oReqCtx.setResponse(ret, new Object[0]);
        }

        return ret;

    }
    public void onLongWaitCanceled(
        JavaReqContext oReqCtx, int iRet,
        String i0 )
    {
        Object oData = oReqCtx.getUserData();
        if (oData != null) {
            ObjPtr oTimer = (ObjPtr)oData;
            this.disableTimer(oTimer);
            // clear the timer object to release
            // the native c++ object, otherwise,
            // it remains till GC works
            oTimer.Clear();
        }
        return;
    }
    
    
}