// GENERATED BY RIDLC. MAKE SURE TO BACKUP BEFORE RE-COMPILING.
package org.rpcf.tests.sftest;
import org.rpcf.rpcbase.*;
import java.io.File;
import java.lang.String;
import java.nio.charset.StandardCharsets;

public class FileTransfersvr extends FileTransfersvrbase
{
    String m_strRootDir =
            "/tmp/sfsvr-root/" + System.getProperty("user.name");
    TransferContext m_oTransCtx = new TransferContext(this);
    public FileTransfersvr( ObjPtr pIoMgr,
        String strDesc, String strSvrObj )
    {
        super( pIoMgr, strDesc, strSvrObj );
        File path = new File(m_strRootDir);
        if(!path.exists())
             path.mkdirs();
    }
    
    // IFileTransfer::StartUpload sync-handler
    public int StartUpload(
        JavaReqContext oReqCtx,
        String strFile,
        long hChannel,
        long qwOffset,
        long qwSize )
    {
        // Synchronous handler. Make sure to call
        // oReqCtx.setResponse before return
        TransFileContext o = new TransFileContext(strFile);
        o.m_cDirection='u';
        o.m_strPath = m_strRootDir + "/" + strFile;
        o.m_lSize = qwSize;
        o.m_lOffset = qwOffset;
        o.m_bServer = isServer();

        int ret = o.openFile();
        if( RC.ERROR(ret))
            return ret;
        m_oTransCtx.addContext(hChannel,o);
        IDeferredCall odc = new IDeferredCall() {
            @Override
            public int getArgCount() {
                return 1;
            }

            @Override
            public Class<?>[] getArgTypes() {
                return new Class[]{long.class};
            }

            @Override
            public void call(Object[] oParams) {
                long hChannel = (Long)oParams[0];
                byte[] buf = new byte[0];
                m_oTransCtx.writeFileAndRecv(hChannel,buf);
            }
        };
        // start to receive after this call returns
        ret = deferCall(odc, new Object[]{hChannel});
        oReqCtx.setResponse(ret);
        return ret;
    }
    
    // IFileTransfer::StartDownload sync-handler
    public int StartDownload(
        JavaReqContext oReqCtx,
        String strFile,
        long hChannel,
        long qwOffset,
        long qwSize )
    {
        // Synchronous handler. Make sure to call
        // oReqCtx.setResponse before return
        TransFileContext o = new TransFileContext(strFile);
        o.m_cDirection='d';
        o.m_strPath = m_strRootDir + "/" + strFile;
        o.m_lSize = qwSize;
        o.m_lOffset = qwOffset;
        o.m_bServer = isServer();
        int ret = o.openFile();
        if( RC.ERROR(ret))
            return ret;
        m_oTransCtx.addContext(hChannel,o);
        IDeferredCall odc = new IDeferredCall() {
            @Override
            public int getArgCount() {
                return 1;
            }

            @Override
            public Class<?>[] getArgTypes() {
                return new Class[]{long.class};
            }

            @Override
            public void call(Object[] oParams) {
                long hChannel = (Long)oParams[0];
                m_oTransCtx.readFileAndSend(hChannel);
            }
        };
        // start sending file data after this call
        ret = deferCall(odc, new Object[]{hChannel});
        oReqCtx.setResponse(ret);
        return ret;
    }
    
    // IFileTransfer::GetFileInfo sync-handler
    public int GetFileInfo(
        JavaReqContext oReqCtx,
        String strFile )
    {
        // Synchronous handler. Make sure to call
        // oReqCtx.setResponse before return
        int ret = RC.STATUS_SUCCESS;
        FileInfo fi = new FileInfo();
        do {
            String strPath = m_strRootDir + "/" + strFile;
            fi.strFile = strFile;
            File o = new File(strPath);
            if (!o.exists())
            {
                ret = RC.ENOENT;
                break;
            }
            if(!o.isFile())
            {
                ret = RC.ENOENT;
                break;
            }
            StringBuilder strBuilder = new StringBuilder();

            if(o.canRead())
                strBuilder.append("r");
            else
                strBuilder.append("-");

            if(o.canWrite())
                strBuilder.append("w");
            else
                strBuilder.append("-");
            if(o.canExecute())
                strBuilder.append("x");
            else
                strBuilder.append("-");
            fi.strAccess = strBuilder.toString();
            fi.qwSize = o.length();

        }while(false);
        if(RC.SUCCEEDED(ret))
            oReqCtx.setResponse(ret, fi);

        return ret;
    }

    public void onWriteStreamComplete(
            int iRet, long hChannel, byte[] buf)
    {
        if(RC.ERROR(iRet))
        {
            rpcbase.JavaOutputMsg(
                    "writeStramAsync faied with error " + iRet);
            return;
        }
        m_oTransCtx.onWriteStreamComplete(hChannel,buf);
    }
    public void onReadStreamComplete(
            int iRet, long hChannel, byte[] buf )
    {
        if(RC.ERROR(iRet))
        {
            rpcbase.JavaOutputMsg(
                    "readStreamAsync faied with error " + iRet);
            return;
        }
        m_oTransCtx.onReadStreamComplete(hChannel,buf);
    }

    @Override
    public int onStmReady(long hChannel) {
        IRpcService.IDeferredCall odc = new IDeferredCall() {
            @Override
            public int getArgCount() {
                return 1;
            }

            @Override
            public Class<?>[] getArgTypes() {
                return new Class[]{long.class};
            }

            @Override
            public void call(Object[] oParams) {
                m_oTransCtx.sendToken(
                        hChannel, "rdy".getBytes(StandardCharsets.UTF_8));
            }
        };
        return deferCall(odc, new Object[]{hChannel});
    }

    @Override
    public int onStmClosing(long hChannel) {
        m_oTransCtx.onTransferDone(
                hChannel, -RC.ECONNABORTED );
        return 0;
    }

    // IFileTransfer::RemoveFile sync-handler
    @Override
    public int RemoveFile(
            JavaReqContext oReqCtx,
            String strFile )
    {
        // Synchronous handler. Make sure to call
        // oReqCtx.setResponse before return
        int ret = 0;
        String strBaseName =
                TransFileContext.getFileName(strFile);
        File oFile = new File(
                m_strRootDir + "/" + strBaseName);
        if(!oFile.delete())
            ret = -RC.ENOENT;
        oReqCtx.setResponse(ret);
        return ret;
    }
}