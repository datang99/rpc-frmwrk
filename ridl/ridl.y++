%{
#include "rpc.h"
#include "lexer.h"

CDeclMap g_oDeclMap;

%}

%define api.value.type {BufPtr}
%define api.pure full

// values
%token TOK_IDENT 
%token TOK_STRVAL
%token TOK_BOOLVAL
%token TOK_BYVAL
%token TOK_INTVAL
%token TOK_FLOATVAL
%token TOK_DBLVAL

// types
%token TOK_STRING
%token TOK_UINT64
%token TOK_INT64
%token TOK_UINT32
%token TOK_INT32
%token TOK_UINT16
%token TOK_INT16
%token TOK_FLOAT
%token TOK_DOUBLE
%token TOK_BYTE
%token TOK_BOOL
%token TOK_BYTEARR
%token TOK_OBJPTR
%token TOK_HSTREAM
%token TOK_ARRAY
%token TOK_MAP

//
%token TOK_INTERFACE
%token TOK_STRUCT
%token TOK_SERVICE

// operators
%token TOK_RETURNS

%token TOK_ASYNC
%token TOK_ASYNCP
%token TOK_ASYNCS
%token TOK_STREAM
%token TOK_SERIAL
%token TOK_TIMEOUT
%token TOK_RTPATH
%token TOK_SSL
%token TOK_WEBSOCK
%token TOK_COMPRES
%token TOK_AUTH

%parse-param { char const *file_name };
%initial-action
{
    YYLTYPE2* pLtype = ( YYLTYPE2* )&@$;
    pLtype->initialize( file_name );
    FILECTX fc( file_name );
    g_vecBufs.push_back( fc );
};

%%

statements :
    %empty
    | statement
    | statement ';' statements
    ;

statement :
    interf_decl
    | service_decl
    | struct_decl
    ;

prime_type :
      TOK_STRING
    | TOK_UINT64
    | TOK_INT64
    | TOK_UINT32
    | TOK_INT32
    | TOK_UINT16
    | TOK_INT16
    | TOK_FLOAT
    | TOK_DOUBLE
    | TOK_BYTE
    | TOK_BOOL
    | TOK_BYTEARR
    | TOK_OBJPTR
    | TOK_HSTREAM
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CPrimeType ) );
        CPrimeType* ppt = pObj;
        ppt->SetName( @1 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

arr_type :
    TOK_ARRAY '<' idl_type '>'
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CArrayType ) );
        CArrayType* pat = pObj;
        pat->SetName( @1 );
        pat->SetElemType( $3 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

map_type :
    TOK_MAP '<' idl_type ',' idl_type '>'
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CMapType ) );
        CMapType* pmt = pObj;
        pmt->SetName( @1 );
        pmt->SetElemType( $5 );
        pmt->SetKeyType( $3 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

struct_ref : TOK_IDENT
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CStructRef ) );
        CStructRef* psr = pObj;
        std::string strName = *$1;

        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( ERROR( ret ) )
        {
            std::string strMsg = "error '"; 
            strMsg += strName + "'";
            strMsg += " not declared yet";
            PrintMsg( -ENOENT, strMsg.c_str() );
        }
        psr->SetName( strName );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

struct_decl : TOK_STRUCT TOK_IDENT '{' field_list '}'
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CStructDecl ) );
        CStructDecl* psr = pObj;
        std::string strName = *$2;
        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( SUCCEEDED( ret ) )
        {
            std::string strMsg = "error '"; 
            strMsg += strName + "'";
            strMsg += " already declared";
            PrintMsg( -EEXIST, strMsg.c_str() );
        }
        psr->SetName( strName );
        ObjPtr pfl = *$3;
        psr->SetFieldList( pfl );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

field_list : field_decl
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CFieldList ) );
        ObjPtr pfdd = *$1;
        CFieldDecl* pfdl = pNode;
        pfdl->AddChild( pfdd );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

field_list : field_decl ';' field_list
    {
        ObjPtr pNode = *$3;
        ObjPtr pfdd = *$1;
        CFieldDecl* pfdl = pNode;
        pfdl->InsertChild( pfdd );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

field_decl : idl_type TOK_IDENT ';'
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CFieldDecl ) );
        std::string strName = *$2;
        CFieldDecl* pfl = pNode;
        pfl->SetName( strName );
        ObjPtr pType = *$1;
        pfl->SetType( pType );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

idl_type :
      prime_type
    | arr_type
    | map_type
    | struct_ref
    { $$ = $1; }
    ;

value :
      TOK_STRVAL
    | TOK_INTVAL
    | TOK_FLOATVAL
    | TOK_DBLVAL
    | TOK_BOOLVAL
    | TOK_BYVAL
    { $$=$1 };
    ;

attr_name : 
      TOK_ASYNC
    | TOK_ASYNCP
    | TOK_ASYNCS
    | TOK_STREAM
    | TOK_SERIAL
    | TOK_TIMEOUT
    | TOK_RTPATH
    | TOK_SSL
    | TOK_WEBSOCK
    | TOK_COMPRES
    | TOK_AUTH
    { $$=@1; }
    ;

attr_exp : attr_name
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExp ) );
        CAttrExp* pae = pNode;
        pae->SetName( $1 );
    }
    ;

attr_exp : attr_name '=' value
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExp ) );
        CAttrExp* pae = pNode;
        pae->SetName( $1 );
        pae->SetValue( $3 );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

attr_exps :  attr_exp
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExps ) );
        ObjPtr pExp = *$1;
        CAttrExps* paes = pNode;
        paes->AddChild( pExp );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;
attr_exps :  attr_exp ',' attr_exps
    {
        ObjPtr pNode = *$3;
        CAttrExps* paes = pNode;
        ObjPtr pExp = *$1;
        paes->InsertChild( pExp );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

attr_list : '[' attr_exps ']'
    {
        ObjPtr pNode = *$2;
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;
    
formal_arg : idl_type TOK_IDENT
    ;

arg_list : formal_arg
    | formal_arg ',' arg_list
    ;

method_decl : TOK_IDENT '(' arg_list ')' TOK_RETURNS '(' arg_list ')'
    | TOK_IDENT '(' ')' TOK_RETURNS '(' arg_list ')'
    ;

method_decls : method_decl
    | method_decl ';' method_decls
    ;

interf_decl : TOK_IDENT '{' method_decls '}'
    ;

interf_ref : TOK_INTERFACE TOK_IDENT attr_list

interf_refs : interf_ref
    | interf_ref ';' interf_refs
    ;

service_decl : TOK_SERVICE TOK_IDENT attr_list '{' interf_refs '}'
    ;
%%

