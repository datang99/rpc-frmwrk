%{
#include "rpc.h"

using namespace rpcfrmwrk;

#include "lexer.h"
#include "astnode.h"

CDeclMap g_oDeclMap;
extern std::vector< FILECTX > g_vecBufs;

%}

%define api.value.type {BufPtr}
%define api.pure full

// values
%token TOK_IDENT 
%token TOK_STRVAL
%token TOK_BOOLVAL
%token TOK_BYVAL
%token TOK_INTVAL
%token TOK_FLOATVAL
%token TOK_DBLVAL

// types
%token TOK_STRING
%token TOK_UINT64
%token TOK_INT64
%token TOK_UINT32
%token TOK_INT32
%token TOK_UINT16
%token TOK_INT16
%token TOK_FLOAT
%token TOK_DOUBLE
%token TOK_BYTE
%token TOK_BOOL
%token TOK_BYTEARR
%token TOK_OBJPTR
%token TOK_HSTREAM
%token TOK_ARRAY
%token TOK_MAP

//
%token TOK_INTERFACE
%token TOK_STRUCT
%token TOK_SERVICE

// operators
%token TOK_RETURNS

%token TOK_ASYNC
%token TOK_ASYNCP
%token TOK_ASYNCS
%token TOK_STREAM
%token TOK_SERIAL
%token TOK_TIMEOUT
%token TOK_RTPATH
%token TOK_SSL
%token TOK_WEBSOCK
%token TOK_COMPRES
%token TOK_AUTH

%parse-param { char const *file_name };
%initial-action
{
    YYLTYPE2* pLtype = ( YYLTYPE2* )&@$;
    pLtype->initialize( file_name );
    FILECTX fc( file_name );
    g_vecBufs.push_back( fc );
};

%%

statements : %empty
    ;

statements : statement
    {
        ObjPtr pNode;
        pNode.NewObj( clisd( CStatements ) );
        CInterfRefs* pstmts = pNode;
        ObjPtr& pstmt = *$1;
        pstmts->AddChild( pstmt );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;
statements : statement ';' statements
    {
        ObjPtr pNode = *$3;
        CInterfRefs* pstmts = pNode;
        ObjPtr& pstmt = *$1;
        pstmts->InsertChild( pstmt );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

statement :
    interf_decl
    | service_decl
    | struct_decl
    { $$ = $1; }
    ;

prime_type :
      TOK_STRING
    | TOK_UINT64
    | TOK_INT64
    | TOK_UINT32
    | TOK_INT32
    | TOK_UINT16
    | TOK_INT16
    | TOK_FLOAT
    | TOK_DOUBLE
    | TOK_BYTE
    | TOK_BOOL
    | TOK_BYTEARR
    | TOK_OBJPTR
    | TOK_HSTREAM
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CPrimeType ) );
        CPrimeType* ppt = pObj;
        ppt->SetName( @1 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

arr_type :
    TOK_ARRAY '<' idl_type '>'
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CArrayType ) );
        CArrayType* pat = pObj;
        pat->SetName( @1 );
        pat->SetElemType( $3 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

map_type :
    TOK_MAP '<' idl_type ',' idl_type '>'
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CMapType ) );
        CMapType* pmt = pObj;
        pmt->SetName( @1 );
        pmt->SetElemType( $5 );
        pmt->SetKeyType( $3 );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

struct_ref : TOK_IDENT
    {
        ObjPtr pObj;
        pObj.NewObj( clsid( CStructRef ) );
        CStructRef* psr = pObj;
        std::string strName = *$1;
        psr->SetName( TOK_STRUCT );

        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( ERROR( ret ) )
        {
            std::string strMsg = "error '"; 
            strMsg += strName + "'";
            strMsg += " not declared yet";
            PrintMsg( -ENOENT, strMsg.c_str() );
        }
        psr->SetName( strName );
        BufPtr pBuf( true );
        pBuf = pObj;
        $$ = pBuf;
    }
    ;

struct_decl : TOK_STRUCT TOK_IDENT '{' field_list '}'
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CStructDecl ) );
        CStructDecl* psr = pNode;
        std::string strName = *$2;
        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( SUCCEEDED( ret ) )
        {
            std::string strMsg = "error '"; 
            strMsg += strName + "'";
            strMsg += " already declared";
            PrintMsg( -EEXIST, strMsg.c_str() );
        }
        psr->SetName( strName );
        ObjPtr& pfl = *$3;
        psr->SetFieldList( pfl );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
        g_oDeclMap.AddDeclNode( strName, pNode );
    }
    ;

field_list : field_decl
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CFieldList ) );
        ObjPtr& pfdd = *$1;
        CFieldDecl* pfdl = pNode;
        pfdl->AddChild( pfdd );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

field_list : field_decl ';' field_list
    {
        ObjPtr& pNode = *$3;
        ObjPtr& pfdd = *$1;
        CFieldDecl* pfdl = pNode;
        pfdl->InsertChild( pfdd );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

field_decl : idl_type TOK_IDENT ';'
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CFieldDecl ) );
        std::string strName = *$2;
        CFieldDecl* pfl = pNode;
        pfl->SetName( strName );
        ObjPtr& pType = *$1;
        pfl->SetType( pType );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

idl_type :
      prime_type
    | arr_type
    | map_type
    | struct_ref
    { $$ = $1; }
    ;

value :
      TOK_STRVAL
    | TOK_INTVAL
    | TOK_FLOATVAL
    | TOK_DBLVAL
    | TOK_BOOLVAL
    | TOK_BYVAL
    { $$=$1 };
    ;

attr_name : 
      TOK_ASYNC
    | TOK_ASYNCP
    | TOK_ASYNCS
    | TOK_STREAM
    | TOK_SERIAL
    | TOK_TIMEOUT
    | TOK_RTPATH
    | TOK_SSL
    | TOK_WEBSOCK
    | TOK_COMPRES
    | TOK_AUTH
    { $$=@1; }
    ;

attr_exp : attr_name
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExp ) );
        CAttrExp* pae = pNode;
        guint32& dwName = *$1;
        pae->SetName( dwName );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

attr_exp : attr_name '=' value
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExp ) );
        CAttrExp* pae = pNode;
        guint32& dwName = *$1;
        pae->SetName( dwName );
        ObjPtr& pValue = *$3;
        pae->SetValue( pValue );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

attr_exps :  attr_exp
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CAttrExps ) );
        ObjPtr& pExp = *$1;
        CAttrExps* paes = pNode;
        paes->AddChild( pExp );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;
attr_exps :  attr_exp ',' attr_exps
    {
        ObjPtr& pNode = *$3;
        CAttrExps* paes = pNode;
        ObjPtr& pExp = *$1;
        paes->InsertChild( pExp );
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;

attr_list : %empty
    ;

attr_list : '[' attr_exps ']'
    {
        ObjPtr pNode = *$2;
        $$.NewObj( true );
        *$$ = pNode;
    }
    ;
    
formal_arg : idl_type TOK_IDENT
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CFormalArg ) );
        std::string strName = *$2;
        CFormalArg* pfa = pNode;
        pfa->SetName( strName );
        ObjPtr& pType = *$1;
        pfl->SetType( pType );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

arg_list : formal_arg
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CArgList ) );
        CArgList* pal = pNode;
        ObjPtr& pArg = *$1;
        pAl->AddChild( pArg );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
arg_list : formal_arg ',' arg_list
    {
        ObjPtr& pNode = *$3;
        ObjPtr& pArg = *$1;
        CArgList* pal = pNode;
        pal->InsertChild( pArg );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

method_decl : TOK_IDENT '(' arg_list ')' TOK_RETURNS '(' arg_list ')'
    {
        ObjPtr pNode;
        pNode.NewObj( clisd( CMethodDecl ) );
        CMethodDecl* pmd = pNode;
        std::string strName = *$1;
        pmd->SetName( strName );
        ObjPtr& pInArgs = *$3;
        pmd->SetInArgs( pInArgs );
        ObjPtr& pOutArgs =  *$7;
        pmd->SetOutArgs( pOutArgs );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
        
    }
    ;
method_decl : TOK_IDENT '(' ')' TOK_RETURNS '(' arg_list ')'
    {
        ObjPtr pNode;
        pNode.NewObj( clisd( CMethodDecl ) );
        CMethodDecl* pmd = pNode;
        std::string strName = *$1;
        pmd->SetName( strName );
        ObjPtr& pOutArgs =  *$6;
        pmd->SetOutArgs( pOutArgs );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

method_decls : method_decl
    {
        ObjPtr pNode;
        pNode.NewObj( clisd( CMethodDecls ) );
        CMethodDecls* pmds = pNode;
        ObjPtr& pmd = *$1;
        pmds->AddChild( pmd );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;
method_decls : method_decl ';' method_decls
    {
        ObjPtr pNode = *$3;
        CMethodDecls* pmds = pNode;
        ObjPtr& pmd = *$1;
        pmds->InsertChild( pmd );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

interf_decl : TOK_IDENT '{' method_decls '}'
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CInterfaceDecl ) );
        CInterfaceDecl* pifd = pNode;
        std::string strName = *$1;
        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( SUCCEEDED( ret ) )
        {
            std::string strMsg = "error interface '"; 
            strMsg += strName + "'";
            strMsg += " already declared yet";
            PrintMsg( -EEXIST, strMsg.c_str() );
        }
        pifd->SetName( strName );
        ObjPtr& pmdl = *$3;
        pifd->SetMethodList( pmdl );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
        g_oDeclMap.AddDeclNode( strName, pNode );
    }
    ;

interf_ref : TOK_INTERFACE TOK_IDENT attr_list
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CInterfRef ) );
        CInterfaceDecl* pifr = pNode;
        std::string strName = *$1;
        ObjPtr pTemp;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( ERROR( ret ) )
        {
            std::string strMsg = "error interface '"; 
            strMsg += strName + "'";
            strMsg += " not declared yet";
            PrintMsg( -ENOENT, strMsg.c_str() );
        }
        pifr->SetName( strName );
        BufPtr pAttrBuf = $3;
        if( ! pAttrBuf.IsEmpty() &&
            ! pAttrBuf->empty() )
        {
            ObjPtr& pal = *$3;
            pifr->SetAttrList( pal );
        }
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

interf_refs : interf_ref
    {
        ObjPtr pNode;
        pNode.NewObj( clisd( CInterfRefs ) );
        CInterfRefs* pifrs = pNode;
        ObjPtr& pifr = *$1;
        pifrs->AddChild( pifr );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

interf_refs : interf_ref ';' interf_refs
    {
        ObjPtr pNode = *$3;
        CInterfRefs* pifrs = pNode;
        ObjPtr& pifr = *$1;
        pifrs->InsertChild( pifr );
        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
    }
    ;

service_decl : TOK_SERVICE TOK_IDENT attr_list '{' interf_refs '}'
    {
        ObjPtr pNode;
        pNode.NewObj( clsid( CServiceDecl ) );
        CServiceDecl* psd = pNode;
        std::string strName = *$2;
        gint32 ret = g_oDeclMap.GetDeclNode(
            strName, pTemp );
        if( SUCCEEDED( ret ) )
        {
            std::string strMsg = "error service '"; 
            strMsg += strName + "'";
            strMsg += " already declared";
            PrintMsg( -EEXIST, strMsg.c_str() );
        }
        psd->SetName( strName );
        BufPtr pAttrBuf = $3;
        if( ! pAttrBuf.IsEmpty() &&
            ! pAttrBuf->empty() )
        {
            ObjPtr& pal = *$3;
            pifr->SetAttrList( pal );
        }
        ObjPtr& pifrs = *$5;
        psd->SetInterfList( pifrs );

        BufPtr pBuf( true );
        pBuf = pNode;
        $$ = pBuf;
        g_oDeclMap.AddDeclNode( strName, pNode );
    }
    ;
%%

// mandatory part, just copy/paste'd from clsids.cpp
static FactoryPtr InitClassFactory()
{
    BEGIN_FACTORY_MAPS;

    INIT_MAP_ENTRY( CBuffer );
    INIT_MAP_ENTRY( CAttrExp );
    INIT_MAP_ENTRY( CAttrExps );
    INIT_MAP_ENTRY( CPrimeType );
    INIT_MAP_ENTRY( CArrayType );
    INIT_MAP_ENTRY( CMapType );
    INIT_MAP_ENTRY( CStructRef );
    INIT_MAP_ENTRY( CFieldDecl );
    INIT_MAP_ENTRY( CFieldList );
    INIT_MAP_ENTRY( CStructDecl );
    INIT_MAP_ENTRY( CFormalArg );
    INIT_MAP_ENTRY( CArgList );
    INIT_MAP_ENTRY( CMethodDecl );
    INIT_MAP_ENTRY( CMethodDecls );
    INIT_MAP_ENTRY( CInterfaceDecl );
    INIT_MAP_ENTRY( CInterfRef );
    INIT_MAP_ENTRY( CInterfRefs );
    INIT_MAP_ENTRY( CServiceDecl );
    INIT_MAP_ENTRY( CStatements );

    END_FACTORY_MAPS;
};

int Usage()
{
    printf( "Usage:" )
    printf( "ridlc [options] <filePath> \n" )
    printf( "\t compile the file",
        "it to current directory" )
    printf( "ridlc -h: print this help")
}

int main( int argc, void** argv )
{
    gint32 ret = 0;
    bool bUninit = false;
    do{
        ret = CoInitialize( COINIT_NORPC );
        if( ERROR( ret ) )
            break;
        bUninit = true;

        FactoryPtr pFactory = InitClassFactory();
        ret = CoAddClassFactory( pFactory );
        if( ERROR( ret ) )
            break;

        int opt = 0;
        int ret = 0;

        while( ( opt =
            getopt( argc, argv, "h" ) ) != -1 )
        {
            switch( opt )
            {
            case 'h' :
                {
                    Usage();
                    break;
                }
            default:
                break;
            }
        }

        if( argv[ optind ] == nullptr )
        {
            printf( "Missing file to compile" );
            Usage();
            break;
        }

        std::string strFile = argv[ optind ];
        ret = yyparse( strFile.c_str() );

        if( argv[ optind + 1 ] != nullptr )
        {
            printf( "Too many arguments" );
            Usage();
            break;
        }

    }while( 0 );

    CoUninitialize();

    return ret;
}
