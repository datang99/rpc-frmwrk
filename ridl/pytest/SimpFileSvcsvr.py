#Generated by RIDLC, make sure to backup before running RIDLC again
from typing import Tuple
from rpcf.rpcbase import *
from rpcf.proxy import *
from seribase import CSerialBase
from fullteststructs import *
import errno

from SimpFileSvcsvrbase import *
class CITinyInterfacesvr( IITinyInterface_SvrImpl ):

    '''
    Synchronous request handler
    '''
    def Ping( self, callback : cpp.ObjPtr
        ) -> Tuple[ int, None ] :
        return [ 0, None ]
        
    '''
    Synchronous request handler
    '''
    def KAReq( self, callback : cpp.ObjPtr,
        qwTaskId : int
        ) -> Tuple[ int, None ] :
        return [ ErrorCode.ERROR_NOT_IMPL, None ]
        
    '''
    Asynchronous request handler
    '''
    def KAReq2( self, callback : cpp.ObjPtr,
        qwTaskId : int
        ) -> Tuple[ int, None ] :
        OutputMsg( "no-reply req KAReq2 is called" )
        return [ 0, None ]
        
    '''
    This method is called when the async
    request is cancelled due to timeout
    or user request. Add your own cleanup
    code here
    '''
    def OnKAReq2Canceled( self,
        callback : cpp.ObjPtr, iRet : int,
        qwTaskId : int ):
        pass
        
    
class CIEchoThingssvr( IIEchoThings_SvrImpl ):

    '''
    Synchronous request handler
    '''
    def Echo( self, callback : cpp.ObjPtr,
        strText : str
        ) -> Tuple[ int, list ] :
        '''
        response parameters includes the following
        strResp : str
        Implement this method here
        '''
        OutputMsg( "strText is %s" % strText )
        return [ 0, [ strText, ] ]
        
    '''
    Synchronous request handler
    '''
    def EchoUnknown( self, callback : cpp.ObjPtr,
        pBuf : bytearray
        ) -> Tuple[ int, list ] :
        '''
        response parameters includes the following
        pResp : bytearray
        Implement this method here
        '''
        return [ 0, [ pBuf, ] ]
        
    '''
    Synchronous request handler
    '''
    def EchoCfg( self, callback : cpp.ObjPtr,
        pObj : cpp.ObjPtr
        ) -> Tuple[ int, list ] :
        '''
        parameters in the response includes
        pRespObj : cpp.ObjPtr
        Implement this method here
        '''
        return [ 0, [ pObj, ] ]
        
    '''
    Asynchronous request handler
    '''
    def EchoMany( self, callback : cpp.ObjPtr,
        i1 : int,
        i2 : int,
        i3 : int,
        i4 : float,
        i5 : float,
        szText : str
        ) -> Tuple[ int, list ] :
        '''
        parameters in the response includes
        i1r : int
        i2r : int
        i3r : int
        i4r : float
        i5r : float
        szTextr : str
        Implement this method here
        '''
        return [ 0, [ i1, i2, i3, i4 + .1,
            i5 + .2, szText ] ]
        
    '''
    This method is called when the async
    request is cancelled due to timeout
    or user request. Add your own cleanup
    code here
    '''
    def OnEchoManyCanceled( self,
        callback : cpp.ObjPtr, iRet : int,
        i1 : int,
        i2 : int,
        i3 : int,
        i4 : float,
        i5 : float,
        szText : str ):
        pass
        
    '''
    Asynchronous request handler
    '''
    def EchoStruct( self, callback : cpp.ObjPtr,
        fi : object
        ) -> Tuple[ int, list ] :
        '''
        parameters in the response includes
        fir : FILE_INFO
        '''
        return [ 0, [ fi, ] ]
        
    '''
    This method is called when the async
    request is cancelled due to timeout
    or user request. Add your own cleanup
    code here
    '''
    def OnEchoStructCanceled( self,
        callback : cpp.ObjPtr, iRet : int,
        fi : object ):
        pass
        
    
class CSimpFileSvcServer(
    CITinyInterfacesvr,
    CIEchoThingssvr,
    PyRpcServer ) :
    def __init__( self, pIoMgr, strDesc, strObjName ) :
        PyRpcServer.__init__( self,
            pIoMgr, strDesc, strObjName )
