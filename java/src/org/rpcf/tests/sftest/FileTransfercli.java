// GENERATED BY RIDLC. MAKE SURE TO BACKUP BEFORE RE-COMPILING.
package org.rpcf.tests.sftest;
import org.rpcf.rpcbase.*;

import java.lang.String;

public class FileTransfercli extends FileTransferclibase
{
    TransferContextCli m_oTransCtx =
            new TransferContextCli(this);
    public FileTransfercli( ObjPtr pIoMgr,
        String strDesc, String strSvrObj )
    { super( pIoMgr, strDesc, strSvrObj ); }


    int uploadFile(long hChannel, String strFile)
    {
        if(hChannel == RC.INVALID_HANDLE || strFile == null)
            return -RC.EINVAL;
        int ret;
        do{
            TransFileContext o =
                    new TransFileContext(strFile);

            o.m_cDirection='u';
            o.m_strPath = strFile;
            o.m_bServer = isServer();

            ret = o.openFile();
            if(RC.ERROR(ret))
                break;
            ret = m_oTransCtx.addContext(hChannel,o);
            if(RC.ERROR(ret))
                break;
            String strRemotName =
                    TransFileContext.getFileName(strFile);
            if(strRemotName.isEmpty())
            {
                ret = -RC.EINVAL;
                break;
            }

            JRetVal jret = StartUpload(
                    strRemotName, hChannel,
                    0, o.m_lSize );

            if(jret.ERROR())
            {
                ret = jret.getError();
                break;
            }
            // start sending
            ret = m_oTransCtx.readFileAndSend(hChannel);
        }while(false);
        return ret;
    }

    int downloadFile(
            long hChannel, String strFile,
            long qwOffset, long qwSize)
    {
        if(hChannel == RC.INVALID_HANDLE || strFile == null)
            return -RC.EINVAL;
        int ret = 0;
        do{
            TransFileContext o =
                    new TransFileContext(strFile);

            o.m_cDirection='d';
            o.m_strPath = "./" + strFile + ".1";
            o.m_bServer = isServer();
            o.m_lOffset = qwOffset;
            o.m_lSize = qwSize;

            ret = o.openFile();
            if( RC.ERROR(ret))
                break;
            ret = m_oTransCtx.addContext(hChannel,o);
            if( RC.ERROR(ret))
                break;

            JRetVal jret = StartDownload(
                    strFile, hChannel, qwOffset, qwSize);
            if(jret.ERROR())
            {
                ret = jret.getError();
                break;
            }

            byte[] buf = new byte[0];
            // start receiving
            ret = m_oTransCtx.writeFileAndRecv(hChannel, buf);

        }while(false);
        return ret;
    }
    public void onWriteStreamComplete(
            int iRet, long hChannel, byte[] buf)
    {
        if(RC.ERROR(iRet))
        {
            rpcbase.JavaOutputMsg(
                    "writeStramAsync faied with error " + iRet);
            return;
        }
        m_oTransCtx.onWriteStreamComplete(hChannel,buf);
    }
    public void onReadStreamComplete(
            int iRet, long hChannel, byte[] buf )
    {
        if(RC.ERROR(iRet))
        {
            rpcbase.JavaOutputMsg(
                    "readStreamAsync faied with error " + iRet);
            return;
        }
        m_oTransCtx.onReadStreamComplete(hChannel,buf);
    }

    @Override
    public int onStmClosing(long hChannel) {
        m_oTransCtx.onTransferDone(
                hChannel, -RC.ECONNABORTED);
        return 0;
    }
}