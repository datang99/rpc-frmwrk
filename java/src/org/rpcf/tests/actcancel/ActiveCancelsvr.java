// GENERATED BY RIDLC. MAKE SURE TO BACKUP BEFORE RE-COMPILING.
package org.rpcf.tests.actcancel;
import org.rpcf.rpcbase.*;
import java.util.Map;
import java.util.HashMap;
import java.lang.String;
import java.nio.ByteBuffer;

public class ActiveCancelsvr extends ActiveCancelsvrbase
{
    public ActiveCancelsvr( ObjPtr pIoMgr,
        String strDesc, String strSvrObj )
    { super( pIoMgr, strDesc, strSvrObj ); }
    
    // IActiveCancel::LongWait async-handler
    public int LongWait(
        JavaReqContext oReqCtx,
        String i0 )
    {
        // Asynchronous handler.
        IUserTimerCb oTimer = new IUserTimerCb() {
            @Override
            public void onTimer(Object octx, int iRet) {
                if( octx == null )
                    return;
                JavaReqContext oReqCtx = (JavaReqContext) octx;
                Object[] oCtx = (Object[]) oReqCtx.getUserData();
                oReqCtx.onServiceComplete(RC.STATUS_SUCCESS, oCtx[1]);
                return;
            }
        };
        JRetVal jret = addTimer( 30,oTimer,oReqCtx);
        if(jret.ERROR())
            return jret.getError();
        // there is a timer object in the return value
        // keep it for clean up usage.
        oReqCtx.setUserData(new Object[]{jret.getAt(0),i0});
        // return pending so that the system has chance to cancel it.
        return RC.STATUS_PENDING;
    }
    public void onLongWaitCanceled(
        JavaReqContext oReqCtx, int iRet,
        String i0 )
    {
        // IActiveCancel::LongWait is canceled.
        if(iRet == RC.ERROR_USER_CANCEL)
            rpcbase.JavaOutputMsg(
                    "the 'LongWait' request is canceled by user with '" + i0 + "'" );
        Object[] oCtx = (Object[])oReqCtx.getUserData();
        if( oCtx == null )
            return;
        ObjPtr oTimer = (ObjPtr) oCtx[0];
        // remove the timer.
        disableTimer(oTimer);
        return;
    }
    
    
}