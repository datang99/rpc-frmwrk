// Generated by ridlc
// This file content could be rewritten by ridlc
#include "rpc.h"
#include "iftasks.h"
using namespace rpcf;
#include "StressTest.h"

gint32 IIEchoThings_PImpl::InitUserFuncs()
{
    BEGIN_IFPROXY_MAP( IEchoThings, false );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIEchoThings_PImpl::EchoDummy,
        "Echo" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIEchoThings_PImpl::EchoUnknownDummy,
        "EchoUnknown" );

    ADD_USER_PROXY_METHOD_EX( 1,
        IIEchoThings_PImpl::PingDummy,
        "Ping" );

    END_IFPROXY_MAP;
    
    BEGIN_IFHANDLER_MAP( IEchoThings );

    ADD_USER_EVENT_HANDLER(
        IIEchoThings_PImpl::OnHelloWorldWrapper,
        "OnHelloWorld" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIEchoThings_PImpl::Echo( 
    IConfigDb* context,
    const std::string& strText,
    std::string& strResp )
{
    gint32 ret = 0;
    TaskletPtr pRespCb_;
    do{
        CParamList oOptions_;
        CfgPtr pResp_;
        oOptions_[ propIfName ] =
            DBUS_IF_NAME( "IEchoThings" );
        oOptions_[ propSeriProto ] = 
            ( guint32 )seriRidl;
        
        CParamList oReqCtx_;
        ObjPtr pTemp( context );
        oReqCtx_.Push( pTemp );
        
        ret = NEW_PROXY_RESP_HANDLER2(
            pRespCb_, ObjPtr( this ), 
            &IIEchoThings_PImpl::EchoCbWrapper, 
            nullptr, oReqCtx_.GetCfg() );

        if( ERROR( ret ) ) break;
        
        //Serialize the input parameters
        BufPtr pBuf_( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf_, strText );
            if( ERROR( ret ) ) break;
            
            pBuf_->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        
        ret = this->AsyncCall(
            ( IEventSink* )pRespCb_, 
            oOptions_.GetCfg(), pResp_,
            "Echo",
            pBuf_ );
        
        if( ret == STATUS_PENDING )
        {
            if( context == nullptr )
                break;
            CCfgOpener oContext( context );
            oContext.CopyProp(
                propTaskId, pResp_ );
            break;
        }
        else if( ERROR( ret ) )
        {
            break;
        }
        CCfgOpener oResp_( ( IConfigDb* )pResp_ );
        oResp_.GetIntProp(
            propReturnValue, ( guint32& )ret );
        if( ERROR( ret ) ) break;
        guint32 dwSeriProto_ = 0;
        ret = oResp_.GetIntProp(
            propSeriProto, dwSeriProto_ );
        if( ERROR( ret ) ||
            dwSeriProto_ != seriRidl )
            break;
        BufPtr pBuf2;
        ret = oResp_.GetBufPtr( 0, pBuf2 );
        if( ERROR( ret ) )
            break;
        
        ObjPtr pDeserialIf_(this);
        CSerialBase oDeserial_( pDeserialIf_ );
        do{
            guint32 dwOrigOff = pBuf2->offset();
            ret = oDeserial_.Deserialize(
                pBuf2, strResp );
            
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( dwOrigOff );
        }while( 0 );

        if( ERROR( ret ) )
            break;
            
        
    }while( 0 );
    if( ERROR( ret ) && !pRespCb_.IsEmpty() )
        ( *pRespCb_ )( eventCancelTask );
    return ret;
}
//Async callback wrapper
gint32 IIEchoThings_PImpl::EchoCbWrapper( 
    IEventSink* pCallback, 
    IEventSink* pIoReq,
    IConfigDb* pReqCtx )
{
    gint32 ret = 0;
    do{
        
        IConfigDb* pResp_ = nullptr;
        CCfgOpenerObj oReq_( pIoReq );
        ret = oReq_.GetPointer(
            propRespPtr, pResp_ );
        if( ERROR( ret ) )
            break;
        
        CCfgOpener oResp_( pResp_ );
        gint32 iRet = 0;
        ret = oResp_.GetIntProp( 
            propReturnValue, ( guint32& ) iRet );
        if( ERROR( ret ) ) break;

        IConfigDb* context = nullptr;
        CCfgOpener oReqCtx_( pReqCtx );
        ret = oReqCtx_.GetPointer( 0, context );
        if( ERROR( ret ) ) context = nullptr;
        
        std::string strResp;
        
        if( SUCCEEDED( iRet ) )
        {
            guint32 dwSeriProto_ = 0;
            ret = oResp_.GetIntProp(
                propSeriProto, dwSeriProto_ );
            if( ERROR( ret ) ||
                dwSeriProto_ != seriRidl )
                break;
            BufPtr pBuf_;
            ret = oResp_.GetBufPtr( 0, pBuf_ );
            if( ERROR( ret ) )
                break;
            
            ObjPtr pDeserialIf_(this);
            CSerialBase oDeserial_( pDeserialIf_ );
            do{
                guint32 dwOrigOff = pBuf_->offset();
                ret = oDeserial_.Deserialize(
                    pBuf_, strResp );
                
                if( ERROR( ret ) ) break;
                
                pBuf_->SetOffset( dwOrigOff );
            }while( 0 );

            if( ERROR( ret ) )
                break;
                
            
        }
        this->EchoCallback(
            context, iRet,
            strResp );
        
    }while( 0 );
    
    return 0;
    
}

gint32 IIEchoThings_PImpl::EchoUnknown(
    BufPtr& pBuf,
    BufPtr& pResp )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IEchoThings" );
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, pBuf );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "EchoUnknown", pBuf_ );
    
    if( ERROR( ret ) ) return ret;
    
    guint32 dwRet_ = 0;
    CCfgOpener oResp_( ( IConfigDb* )pResp_ );
    ret = oResp_.GetIntProp(
        propReturnValue, dwRet_ );
    if( ERROR( ret ) ) return ret;
    ret = ( gint32 )dwRet_;
    
    if( ERROR( ret ) ) return ret;
    guint32 dwSeriProto_ = 0;
    ret = oResp_.GetIntProp(
        propSeriProto, dwSeriProto_ );
    if( ERROR( ret ) ||
        dwSeriProto_ != seriRidl )
        return ret;
    BufPtr pBuf2;
    ret = oResp_.GetBufPtr( 0, pBuf2 );
    if( ERROR( ret ) )
        return ret;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf2->offset();
        ret = oDeserial_.Deserialize(
            pBuf2, pResp );
        
        if( ERROR( ret ) ) break;
        
        pBuf2->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    
    return ret;
}

gint32 IIEchoThings_PImpl::Ping(
    const std::string& strCount )
{
    gint32 ret = 0;
    CParamList oOptions_;
    CfgPtr pResp_;
    oOptions_[ propIfName ] =
        DBUS_IF_NAME( "IEchoThings" );
    oOptions_[ propNoReply ] = true;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strCount );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    
    ret = this->SyncCallEx(
        oOptions_.GetCfg(), pResp_, 
        "Ping", pBuf_ );
    
    return ret;
}

gint32 IIEchoThings_PImpl::OnHelloWorldWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strMsg;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strMsg );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    OnHelloWorld(strMsg );

    return ret;
}
gint32 IIEchoThings_SImpl::InitUserFuncs()
{
    BEGIN_IFHANDLER_MAP( IEchoThings );

    ADD_USER_SERVICE_HANDLER(
        IIEchoThings_SImpl::EchoWrapper,
        "Echo" );
    
    ADD_USER_SERVICE_HANDLER(
        IIEchoThings_SImpl::EchoUnknownWrapper,
        "EchoUnknown" );
    
    ADD_USER_SERVICE_HANDLER(
        IIEchoThings_SImpl::PingWrapper,
        "Ping" );
    
    END_IFHANDLER_MAP;
    
    return STATUS_SUCCESS;
}

gint32 IIEchoThings_SImpl::EchoWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strText;
    std::string strResp;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strText );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Echo(
        strText,
        strResp );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, strResp );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIEchoThings_SImpl::EchoUnknownWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    BufPtr pBuf;
    BufPtr pResp;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, pBuf );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = EchoUnknown(
        pBuf,
        pResp );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }

    CParamList oResp_;
    oResp_[ propReturnValue ] = ret;
    oResp_[ propSeriProto ] = seriRidl;
    if( SUCCEEDED( ret ) )
    {
        BufPtr pBuf2( true );
        
        ObjPtr pSerialIf_(this);
        CSerialBase oSerial_( pSerialIf_ );
        do{
            ret = oSerial_.Serialize(
                pBuf2, pResp );
            if( ERROR( ret ) ) break;
            
            pBuf2->SetOffset( 0 );
        }while( 0 );

        if( ERROR( ret ) )
            return ret;
        oResp_.Push( pBuf2 );
    }
    
    this->SetResponse( 
        pCallback, oResp_.GetCfg() );
    
    return ret;
}

gint32 IIEchoThings_SImpl::PingWrapper( 
    IEventSink* pCallback, BufPtr& pBuf_ )
{
    gint32 ret = 0;
    std::string strCount;
    
    ObjPtr pDeserialIf_(this);
    CSerialBase oDeserial_( pDeserialIf_ );
    do{
        guint32 dwOrigOff = pBuf_->offset();
        ret = oDeserial_.Deserialize(
            pBuf_, strCount );
        
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( dwOrigOff );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
        
    ret = Ping(
        strCount );
    if( ret == STATUS_PENDING )
    {
        ret = ERROR_STATE;
        DebugPrintEx( logErr, ret, 
            "Cannot return pending with"
            "Sync Request Handler" );
    }
    return ret;
}

gint32 IIEchoThings_SImpl::OnHelloWorld(
    const std::string& strMsg )
{
    gint32 ret = 0;
    CParamList oOptions_;
    oOptions_[ propSeriProto ] = 
        ( guint32 )seriRidl;
    //Serialize the input parameters
    BufPtr pBuf_( true );
    
    ObjPtr pSerialIf_(this);
    CSerialBase oSerial_( pSerialIf_ );
    do{
        ret = oSerial_.Serialize(
            pBuf_, strMsg );
        if( ERROR( ret ) ) break;
        
        pBuf_->SetOffset( 0 );
    }while( 0 );

    if( ERROR( ret ) )
        return ret;
    ret = this->SendEventEx(
        nullptr, oOptions_.GetCfg(),
        iid( IEchoThings ), 
        USER_EVENT( "OnHelloWorld" ), "",
        pBuf_ );

    return ret;
}
