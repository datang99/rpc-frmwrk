# Generated by RIDLC, make sure to backup before recompile
# ridlc -spf --async_proxy -O . ../../../../examples/katest.ridl 
import sys
from rpcf import iolib
from rpcf import serijson
import errno
from rpcf.proxy import ErrorCode as Err
from typing import Union, Tuple, Optional
from kateststructs import *
from ifimpl import *
import random
import threading

class CIKeepAlivecli( IIKeepAlive_CliImpl ):
    '''
    Asynchronous callback to receive the 
    request status, and reponse parameters
    if any. And add code here to process the
    request response
    '''
    def LongWaitCallback( self,
        reqId : int, ret : int, i0r : str ) :
        if ret < 0 :
            error = ret
            print( "LongWait 2 failed with error %d" % error )
            return
        print( "LongWait completed with response %s" % i0r )
        self.m_semWait.release()
    
class CKeepAliveProxy(
    CIKeepAlivecli) :
    def __init__( self, strSvcPoint : str, num : int ) :
        if num is None:
            num = 0
        self.m_strPath = strSvcPoint
        reqFile = strSvcPoint + "/jreq_" + str( num )
        self.m_reqFp = open( reqFile, "wb" )
        respFile = strSvcPoint + "/jrsp_" + str( num )
        self.m_respFp = open( respFile, "rb" )
        evtFile = strSvcPoint + "/jevt_" + str( num )
        self.m_evtFp = open( evtFile, "rb" )
        self.m_semWait = threading.Semaphore(0)
        
    def sendReq( self, oReq : object ) -> int:
        return iolib.sendReq( self.m_reqFp, oReq )
    
    def recvResp( self ) -> Tuple[ int, object ]:
        return iolib.recvResp( self.m_respFp )
    
    def getRespFp( self ) -> object:
        return self.m_respFp
    
    def getEvtFp( self ) ->  object:
        return self.m_evtFp
    
    def CancelRequest( self, reqId2Cancel : int ) -> int:
        error = 0
        try:
            oReq = dict()
            oParams = dict()
            oReq[ "MessageType" ] = "req"
            oReq[ "Interface" ] = "IInterfaceServer"
            oReq[ "Method" ] = "UserCancelRequest"
            oReq[ "RequestId" ] = random.randint( 0, 0x100000000 )
            oParams[ "RequestId" ] = reqId2Cancel
            oReq[ "Parameters" ] = oParams
            ret = self.sendReq( oReq )
            if ret < 0:
                error = ret
                raise Exception( "Error sending req %d" % error  )
            return Err.STATUS_PENDING
        except Exception as err:
            print( err )
            if error < 0 :
                return error
            return -errno.EFAULT
        
    def OnUserCancelReqCbWrapper( self, oResp : object ):
        error = 0
        try:
            oParams = oResp[ "Parameters" ]
            reqIdCanceled = oParams[ "RequestId" ]
            retCode = oResp[ "ReturnCode" ]
            self.OnUserCancelRequstComplete( retCode, reqIdCanceled )
        except Exception as err:
            print( err )
            return
        
    '''
     adding your cancel handler here 
    '''
    def OnUserCancelRequstComplete( self,
        ret : int, reqIdToCancel : int ):
        print( "CancelRequest %d completed with status %d" % ( reqIdToCancel, ret ) )

    def DispatchMsg( self, oResp : dict ):
        try:
            if "IKeepAlive" == oResp[ "Interface" ] :
                IIKeepAlive_CliImpl.DispatchIfMsg( self, oResp )
                return
            if "IInterfaceServer" == oResp[ "Interface" ] and "UserCancelRequest" == oResp[ "Method" ] :
                self.OnUserCancelReqCbWrapper( oResp )
            return
        except Exception as err:
            print( err )
            return
        
    
