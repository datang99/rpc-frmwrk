# Generated by RIDLC, make sure to backup before recompile
# ridlc -spf --async_proxy -O . ../../../../examples/katest.ridl 
import sys
from rpcf import iolib
from rpcf import serijson
import errno
from rpcf.proxy import ErrorCode as Err
from typing import Union, Tuple, Optional
from kateststructs import *
from ifimpl import *
import threading
import time

class KAThread(threading.Thread):
    def __init__(self , threadName,
        svr : object,
        reqId : object,
        i0 : str ):
        super().__init__(name=threadName)
        self.m_reqId = reqId
        self.m_oSvr = svr
        self.m_i0 = i0

    def run(self):
        period = 0
        kaInterval = 3 
        while period < 20 :
            time.sleep( kaInterval )
            self.m_oSvr.OnKeepAlive( self.m_reqId )
            period += kaInterval
            print( ".", end=None )
        self.m_oSvr.LongWaitCompleteCb(
            self.m_reqId, 0, self.m_i0 )
        
class CIKeepAlivesvr( IIKeepAlive_SvrImpl ):
    '''
    Asynchronous request handler
    within which to run the business logic.
    Returning Err.STATUS_PENDING for an
    asynchronous operation and returning other
    error code will complete the request. if the
    method returns STATUS_PENDING, make sure to
    call "self.LongWaitCompleteCb" later to
    complete the request. Otherwise, the client
    will get a timeout error. The return value is a
    list, with the first element as error code and
    the second element as a list of the response
    parameters.
    '''
    def LongWait( self, reqId : object,
        i0 : str
        ) -> Tuple[ int, list ] :
        #Implement this method here
        kathread = KAThread( "KeepAliveThrd",
            self, reqId, i0 )
        kathread.start()
        return [ Err.STATUS_PENDING, None ]
        
    
class CKeepAliveServer(
    CIKeepAlivesvr ) :
    def __init__( self, strSvcPoint : str, num : int ) :
        if num is None:
            num = 0
        error = 0
        self.m_strPath = strSvcPoint
        reqFile = strSvcPoint + "/jreq_" + str( num )
        self.m_reqFp = open( reqFile, "rb" )
        respFile = strSvcPoint + "/jrsp_" + str( num )
        self.m_respFp = open( respFile, "wb" )
        
    def sendResp( self, oResp : object ) -> int:
        return iolib.sendResp( self.m_respFp, oResp )
    
    def sendEvent( self, oEvent : object ) -> int:
        return iolib.sendEvent( self.m_respFp, oEvent )
    
    def recvReq( self ) -> Tuple[ int, object ]:
        return iolib.recvReq( self.m_reqFp )
    
    def getReqFp( self ) ->  object:
        return self.m_reqFp
    
    def OnKeepAlive( self, reqId : object ) -> int:
        if reqId is None:
            return -errno.EINVAL
        oResp = dict()
        oResp[ "RequestId" ] = reqId
        oResp[ "Method" ] = "OnKeepAlive"
        oResp[ "Interface" ] = "IInterfaceServer"
        oResp[ "MessageType" ] = "evt"
        return self.sendEvent( oResp )
    
    def DispatchMsg( self, oReq : dict ):
        try:
            if "IKeepAlive" == oReq[ "Interface" ] :
                IIKeepAlive_SvrImpl.DispatchIfMsg( self, oReq )
                return
            if "IInterfaceServer" == oReq[ "Interface" ] and "UserCancelRequest" == oReq[ "Method" ] :
                reqId = oReq[ "RequestId" ]
                oParams = oReq[ "Parameters" ]
                reqIdToCancel = oParams[ "RequestId" ]
                self.UserCancelRequest( reqId, reqIdToCancel )
                return
            
        except Exception as err:
            print( err )
            return
        
    def UserCancelRequest( self, reqId : object,
        reqIdToCancel : object ) -> int:
        # change this function for customized behavor
        print( "request", reqIdToCancel, " is canceled" )
        oParams = dict()
        oParams[ "RequestId" ] = reqIdToCancel
        oResp = BuildReqHeader( reqId,
            "UserCancelRequest",
            "IInterfaceServer",
            0, False, True )
        oResp[ "Parameters" ] = oParams
        return self.sendResp( oResp )
    
